---
title: "[백준]11657번 - 타임머신"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 최단경로, 다익스트라, 벨만 포드]
---

# 타임머신

## 문제

N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작도시, B는 도착도시, C는 버스를 타고 이동하는데 걸리는 시간이다. 시간 C가 양수가 아닌 경우가 있다. C = 0인 경우는 순간 이동을 하는 경우, C < 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.

1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다. 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다. 

### 출력

만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다. 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다. 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.

## 문제풀이

문제 설명란에 벨만 포드 알고리즘으로 푸는것이라고 설명이 되어있어서 벨만포드 알고리즘을 알아왔다. 

### 벨만 포드 알고리즘

다익스트라 알고리즘의 경우 그래프에 무한이 뺄셈을 반복하는 구간이 있다면 해당구간을 계속 순환하는 부분이 생길 수 있다. 벨만포드 알고리즘은 이에 대응 하기 위해 나온 알고리즘이다.

![img](https://blog.kakaocdn.net/dn/bQ3wfg/btqzzKi3C8y/kpIlyMC4sJqRqQz0stn9aK/img.png)

위와 같은 구간에서 s->e->f->g같은 구간이 문제라는 것입니다.

이러한 경우를 보고 다음과 같은 결론이 생깁니다

#### 최단경로는 쉰환을 포함해서는 안되므로 경로의 길이는 최대 |V|-1이다.

각 정점에 대해 정점과 연결된 모든간선을 확인하며, 길이를 업데이트 해준다.

그 이후 한번더 연결된 간선들을 확인해 주는데 그 확인에 변동되는곳이 있다면, 그곳은 음수간선으로 인한 사이클이 있다는 뜻입니다. 이 경우에는 False즉, 음의 사이클이있어서 최소비용을 알 수 없음을 반환합니다.

### 문제풀이로 돌아 와서

여기서 -1이 출력되는 경우는 둘이다. 

- 시간을 무한히 오래전으로 되돌릴수있는경우: 즉, 음수사이클이 있는경우
- 도시로 가는 경로가 없는경우

나머지의 경우는 길이를 변환한다.

두 경우도 다른데, 길이가 INF일경우에는 경로대신 -1d을 표기하고, 아예 음수사이클이있을때에는 첫줄에만 -1을 출력한다.

### 의사코드

> 1. 입력을 받는다.
> 2. 그래프를 만든다.
> 3. 벨만 포드 함수를 만든다
>    1. 시작노드의 거리를 0으로 초기화한다.
>    2. 정점 수만큼 반복
>       1. 모든 간선 확인
>          1. 현재노드 확인
>          2. 다음노드 확인
>          3. 가중치 받아오기
>          4. 현재 노드를 거쳐 다른노드로 이동하는 거리가 더 짧은경우
>             1. 간선을 업데이트 한다
>                1. 만약 n번만큼 반복됬다면 음수사이클이 존재한다는것이므로 False를 반환한다.
>    3. True를 반환한다.
> 4. 벨만 포드 함수에 1 을 넣는다.
> 5. 결과가 False라면 -1을 출력한다
> 6. 아니라면 2번도시부터 n번도시까지의 거리를 출력한다
>    1. 단, 거리가 INF면 -1을 출력한다.

### python code

```python
import sys
import heapq
n,m=map(int,sys.stdin.readline().split())
edge=[]
INF=60000001
for _ in range(m):
    a,b,c=map(int,sys.stdin.readline().split())
    edge.append([a,b,c]) # 벨만포드는 그래프내용은필요한데 이전처럼 딕셔너리로 위치찾기를 하면 반복횟수를 세는데에 어려움이있어서 이렇게 처리함
dist=[INF]*(n+1)
def bF():
    global dist
    dist[0]=0;dist[1]=0# 원래는 출발점에 따라서 적용되야 겠지만, 이건 무조건 1번출발이라 이렇게 만들어짐
    for i in range(n):
        prev_dist=list(dist)
        for j in range(m):
           node=edge[j][0]
           nextNode=edge[j][1]
           cost=edge[j][2]
           if dist[node]!= INF and dist[nextNode] > dist[node]+cost:
                dist[nextNode]= dist[node]+cost
                if i == n-1 :
                    return False
        if prev_dist==dist:
            return True
    return True

nc=bF()
if nc:
    for i in dist[2:]:
        if i ==INF:
            print(-1)
        else :
            print(i)
else:
    print(-1)
```

 
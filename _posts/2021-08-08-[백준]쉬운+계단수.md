---
title: "[백준]쉬운 계단수"
categories: 코딩테스트
tags: [알고리즘, 코딩테스트, 동적계획법, python]
---

# 쉬운 계단수

## 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.

세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.



## 문제풀이

이 문제는 얼핏봤을때 매우 어려워 보이지만 생각보다 간단하게 풀 수 있다.

두자리 계단수 XY가 있을때 Y는 X+1이거나 X-1일것이다. 즉 X가 1이아니라면 무조건적으로 두자리 계단수 n의 개수 *2만큼의 수가 된다.

앞자리는 0이 될 수 없으므로, 뒷자리를 기록하는것이 더 좋을것 이고, 이에 따라 2차원 배열을 만들어 몇번째 열에 뒷자리수가 몇개인지 정리한후 그것을 모두 더하면 결과가 나올것이다. 이에 따라 생성되는 의사코드는 다음과 같다.

### 의사코드

>1. 입력받는다
>
>2. n번째자리까지 저장할 것을 선언한다.
>
>3. n번째 자리가 될때까지 뒷자리에 따라 정리한다.
>
>   > 1. 자리수가 i, 현재수의 뒷자리가 j, 계단수의 저장 배열명을 count라고 할때 i가 0이거나 9가 아니라면  count\[i][j]=count\[i-1][j-1]+count\[i-1][j+1] 이다. 계산의 속도를 위해 이곳에서도, 정답을 나눠주도록 하자.
>   > 2. i가 0이나 9면 그에 맞게 바꾸어 풀어준다.
>
>4. n번째자리의 모든수를 더한후 나머지를 구해 출력한다.



### 파이썬 코드

```python
import sys
n= int(sys.stdin.readline())
counts=[[0]+[1]*9 for _ in range(n)]
for i in range(1,n):
    for j in range(10):
        if j==0 :
            counts[i][0]=counts[i-1][1]
        elif j==9 :
            counts[i][9]=counts[i-1][8]
        else :
            counts[i][j]=(counts[i-1][j-1]+counts[i-1][j+1])%1000000000
print(sum(counts[-1])%1000000000)
```




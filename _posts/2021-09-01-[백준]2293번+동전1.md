---
title: "[백준]2293번 - 동전1"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 다이나믹 프로그래밍 2, 동적계획법2]
---

# 동전 1

## 문제

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다

### 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

## 문제풀이

일단 예제를 보자.

1, 2, 5로 10을 만들수 있는경우는 다음과 같다.

1\*10, 1\*8+2, 1\*6+2\*2, 1\*4+2\*3, 1\*2+2\*4, 2\*5, 1\*5+5\*1, 1\*3+2\*1+5\*1, 1*1+2\*2+5\*1, 5\*2

그리고 이것을 적으면서 생각해본 dp\[i][j]는 i번째 숫자까지 써서 j를 만들 수 있는 경우의수이다.

- dp\[i-1][j-num[i]*k]>0 이면, dp\[i][j]+=dp\[i][j-num[i]\*k]이다.  #현재 숫자의 중복사용이 허용이기때문에 뒤쪽이 [i-1]이 아니라 i이다.
- dp\[i-1][j] >0 이면, dp\[i][j]+=dp\[i-1][j] 이다
- dp\[0][0]=1

그러니까 만약 5가 하나 들어가는 10을 만들고 싶은경우에는 1,2 로만 5를 이루는 경우의 개수 만큼 10을 만들수 있다는 이야기다. 그리고 목표는 10이기 때문에 1과 2로만 10을 만드는것과 5로만 10을 만드는 숫자도 더해줘야 10을 만들수 있다.

그리고 위 dp들을 이용하면 다음과 같은 식을 만들 수 있다.
$$
dp[i][j]=\begin{cases}dp[i-1][j]\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\;(j<nums[i-1])\\dp[i][j-nums[i-1]+dp[i-1][j]\quad\quad(j≥nums[i-1])\end{cases}
$$


### 의사코드

> 1. 입력받는다.
> 2. (n+1)*(k+1)인 dp를 선언한다, dp\[0][0]=1
> 3. i를 0~n-1까지 반복
>    1. j를 0부터 k까지 반복
>       1. 만약 j가 nums[i]보다 작아서 새 돈을 추가 못하면 dp\[i+1][j]=dp\[i][j]
>       2. 그게 아니면 dp\[i+1][j]=dp\[i][j]+dp\[i+1][j-nums[i]]
> 4. dp\[n][k]를 출력

### 파이썬 코드

```python
import sys
n,k = map(int, sys.stdin.readline().split())
nums=[int(sys.stdin.readline()) for _ in range(n)]
dp=[[0]*(k+1) for _ in range(n+1)]
dp[0][0]=1
for i in range(0,n):
    for j in range(0,k+1):
        if j<nums[i]: dp[i+1][j]=dp[i][j]
        else: dp[i+1][j]=dp[i][j]+dp[i+1][j-nums[i]]
print(dp[n][k])
```

하지만 이 점화식대로 진행하면 메모리 초과가 나온다.

하지만 놀랍게도 여기서 더 메모리를 줄일 방법이있는데 위 dp점화식이 기본적으로 dp\[i+1][j]가 dp\[i][j]를 포함하고 j의 연산은 자기자신을 제외하고는 더하는게 i+1열인것을 생각하면 이 점화식을 1차원으로 줄여버릴 수 있다. 우리는 어짜피 메모리가 부족한 것이다.

그러면 이것을 1차원으로 바꾸면 다음과 같은 코드가 된다.

### 파이썬 코드

```python
import sys
n,k = map(int, sys.stdin.readline().split())
nums=[int(sys.stdin.readline()) for _ in range(n)]
dp=[0]*(k+1) 
dp[0]=1
for i in range(0,n):
    for j in range(0,k+1):
        if j>=nums[i]:
           dp[j]+=dp[j-nums[i]]
print(dp[k])
```


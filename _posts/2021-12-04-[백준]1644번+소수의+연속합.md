---
title: "[백준]1644번 - 소수의 연속합"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 투포인터]
---

# 소수의 연속합

## 문제

하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.

- 3 : 3 (한 가지)
- 41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)
- 53 : 5+7+11+13+17 = 53 (두 가지)

하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.

자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)

### 출력

첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.

## 문제풀이

일단 이전의 투포인트 부분합 문제와 같이 진행하는데, 여기에 필요한것은 소수를 이용한 list이다. 

원래는 6000000까지를 그냥 코드로 넘길 예정이였으나, 실제로 해본 결과 백준사이트에서 에러가났다. 아마도 너무 많은 문자를 넘겨서 그런듯하다. 그래서 전부 코드로 만들었다.

즉, 코드는 다음과 같은 진행을 가진다.

### 의사코드

> 1. 에라토스테네스의 체 알고리즘을 이용하여 소수를 찾아 리스트를 만든다.
> 2. 투포인터 알고리즘으로 연속합을 구한다

### 파이썬 코드

```python
import sys
N=int(sys.stdin.readline())
prime=[True]*(N+1)
prime[0]=False;prime[1]=False
for i in range(2, N+1):
    if prime[i]:
        for j in range(2*i,N+1,i):
            prime[j]=False
primeNum=[]
for i in range(2,N+1):
    if prime[i]:
        primeNum.append(i)
s=0;e=0;c=0;l=len(primeNum)
if primeNum:
    sn=primeNum[0]
while(e<l):
    if sn<N:
        e=e+1
        if e>=l:
            break
        sn=sn+primeNum[e]
    elif sn>N:
        sn=sn-primeNum[s]
        s=s+1
    else:
        c+=1
        e=e+1
        if e>=l:
            break
        sn=sn-primeNum[s]+primeNum[e]
        s=s+1
print(c)
```

뭔가 평소보다 부실해 보인다면, 여기다가 별생각 없이 구해놓은 600만까지의 소수를 복붙했다가 원래 썻던글이 폭발했기 때문이다.
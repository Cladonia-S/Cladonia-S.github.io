---
title: "[백준]1753번 - 최단경로"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 최단경로]
---

# 최단경로

## 문제

방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.

### 입력

첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.

### 출력

첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.

## 문제풀이

백준의 단계별로 풀어보기에서 처음으로 방향 그래프와 가중치가 나왔다. 이 문제는 다익스트라(Dijkstra)알고리즘을 사용하는것이다.

### 다익스트라 알고리즘

나중에 좀더 자세히 다루겠고 지금은 간단히만 설명하겠습니다.

다익스트라 알고리즘은 하나의 정점에서 다른 모든정점으로 가는 최소비용를 알려주는 알고리즘입니다.  최단거리는 여러개의 최단거리로 이루어져 있기때문에, 다이나믹 프로그래밍으로 구성되어있습니다.

다익스트라 알고리즘은 현재까지 알고있던 최단경로를 계속해서 갱신하는 알고리즘입니다. 만약 지금 알고있는 비용이 5인데 방금 어딘가를 경우해서 오는 비용이 4라면 4로 갱신되는 그런 방법이지요.

동작 과정은 다음과 같습니다.

1. 시작노드를 정합니다.
2. 시작노드를 기준으로 각 노드까지의 최소비용을 저장합니다.
3. 갈 수 있는 노드중 가장 비용이 적게드는 노드를 선택합니다.
4. 해당노드를 거쳐 특정한 노드로 가는경우를 고려하여 최소비용을 갱신합니다.
5. 위 과정을 반복합니다.

### 돌아와서

최소 가중치를 일일히 확인하는것은 힘든일이므로 최소힙을 사용해서 가장 가중치가 적은 노드를 선택하는것이 좋습니다.

위의 과정들을 따라서 의사코드를 작성하면 다음과 같습니다.

### 의사코드

> 1. 입력을 받는다.
> 2. 그래프를 만든다.
> 3. 루트노드에서의 거리를 기준으로 현재 바로 갈수있는 노드들의 비용을 정리하고, 가지못하는 노드들의 비용은 3000001로 한다. 이유는 최대가중치가 10이고 간선의 최대개수가 300000이기때문에 아무리 돌고돌아 간곳이라도 3000000초과의 값이 안나오기때문에 저수로 지정을 하면 못가는 곳이라는 의미가 되기때문이다.
> 4. 다익스트라 함수를 만든다.
>    1. 노드거리를 저장한 배열을 전역으로 선언한다.
>    2. 현재노드에서 갈 수 있는 모든 노드의 정보를 최소 힙에 넣는다.
>    3. 힙이 빌때까지 반복
>       1.  현재 테이블과 비교해 더 가중치가 크면 무시
>       2. 다음 노드 까지의 가중치가 현재 기록된값보다작으면 값을 업데이트
>       3. 다음점가지의 가중치와 다음점에 대한 정보를 최소힙에 삽입

### 파이썬 코드

```python
import sys
import heapq
V,E= map(int, sys.stdin.readline().split())
K=int(sys.stdin.readline())
distance=[3000001]*(V+1)
graph=[[] for _ in range (V+1)]
for i in range(E):
    u,v,w=map(int,sys.stdin.readline().split())
    graph[u].append([v,w])
heap=[]
distance[K]=0
heapq.heappush(heap,[0,K])
while heap:
    weight, node=heapq.heappop(heap)
    if distance[node] < weight :
        continue
    for nnode, w in graph[node]:
        nextW=w+weight
        if nextW < distance[nnode]:
            distance[nnode]=nextW
            heapq.heappush(heap,[nextW,nnode])
for i in distance[1:]:
    print("INF" if i==3000001 else i)
```


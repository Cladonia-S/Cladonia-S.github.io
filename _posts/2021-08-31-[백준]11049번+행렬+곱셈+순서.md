---
title: "[백준]11049번 - 행렬 곱셈 순서"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 다이나믹 프로그래밍 2]
---

# 행렬 곱셈 순서

## 문제

크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.

예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.

- AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.
- BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.

같은 곱셈이지만, 곱셈을 하는 순서에 따라서 곱셈 연산의 수가 달라진다.

행렬 N개의 크기가 주어졌을 때, 모든 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값을 구하는 프로그램을 작성하시오. 입력으로 주어진 행렬의 순서를 바꾸면 안 된다.

### 입력

첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.

둘째 줄부터 N개 줄에는 행렬의 크기 r과 c가 주어진다. (1 ≤ r, c ≤ 500)

항상 순서대로 곱셈을 할 수 있는 크기만 입력으로 주어진다.

### 출력

## 문제풀이

`dp[i][j]=i번 행렬부터 j번 행렬까지 곱했을때 최소 곱셈수`

`dp[i][i]=0` `dp[i][i+1]=cost[i][0]*cost[i][1]*cost[i+1][1]`

`dp[i][i+2]=min(dp[i][i+2]*cost[i+2][0]*cost[i+2][1], dp[i+1][i+2]*cost[i][0]*cost[i][1])`

이 문제는 행렬 곱셈 문제이기 때문에 중간부분만 따로 떨어져서 계산을 하는경우는 없다. 

따라서 `dp[i][j]=min(dp[i][k]+dp[k+1][j]+cost[i][0]*cost[k][1]*cost[j][1])   i≤k≤j`가 될 것이다.  기초선언이 대각선임에 따라서 이 계산은 대각선 형식으로 굴러가는게 편할듯 하다. 그러니 곱하는길이에 대한 변수를 따로 선언하고, 그것을 변화시키는것으로 연산을 이어가는게 편하다.

따라서 의사코드는 다음과 같게 된다.

### 의사코드

> 1. 입력받는다.
> 2. N>1이면
>    1. `dp[i][i+1]`을 위 식에따라 설정한다.
>    2. 연산길이(ol)를 2으로 시작해 행렬개수N까지로 연산을 반복한다.
>       1. i를 0부터 n-ol+1동안 반복
>          1. j=i+ol
>          2. `dp[i][j]=2³¹-1`# 최소비교를 위해서 말도 안되는 값을 집어넣는것이다.
>          3. k를 i부터 j까지 반복
>             1. `dp[i][j]=min(dp[i][j], dp[i][k]+dp[k+1][j]+cost[i][0]*cost[k][1]*cost[j][1])`
>    3. `dp[0][n-1]`출력
> 3. N==1 : 0출력

### 파이썬 코드

```python
import sys
n=int(sys.stdin.readline())
mat=[list(map(int,sys.stdin.readline().split())) for _ in range(n)]
if n==1: print(0)
else :
    dp=[[0]*n for _ in range(n)]
    for i in range(n-1):
        dp[i][i+1]=mat[i][0]*mat[i][1]*mat[i+1][1]
    for ol in range(2, n):
        for i in range(0,n-ol+1):
            j=i+ol
            if j>n-1 : break
            dp[i][j]=2**31-1
            for k in range(i,j):
                dp[i][j]=min(dp[i][j], dp[i][k]+dp[k+1][j]+mat[i][0]*mat[k][1]*mat[j][1])
    print(dp[0][n-1])
```

안타깝게도 pypy3가 아니면 시간초과가 뜬다.
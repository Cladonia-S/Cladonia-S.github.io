---
title: "[백준]2545번 - 팬케익 먹기"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬]
---

# 팬케익 먹기

## 문제

오늘 아침 은주는 팬케익을 만들었다. 자 이제 신혜는 이 팬케익을 먹으려고 한다.

은주가 만든 팬케익은 박스 모양이고, 가로 Acm, 세로 Bcm, 높이 Ccm 크기이다.

신혜는 팬케익을 D번 먹으려고 한다. 매번 신혜가 팬케익을 먹으려고 할 때, 은주는 팬케익을 변에 평행하게 자른 후에 신혜에게 준다.

은주는 뛰어난 요리사이기 때문에, 자르는 케익은 모두 두께가 1cm이다.

원래 은주는 팬케익을 다 먹으려고 했으나, 어쩔수 없이 신혜에게 주는 것이다. 따라서, 최대한 많은 양을 남기려고 한다.

신혜가 팬케익을 D번 먹은 후에 남은 케익의 양은 은주가 케익을 자르는 방법에 따라서 달라지게 된다.

A, B, C, D가 주어졌을 때, 신헤가 팬케익을 D번 먹은 후에 남은 팬케익 부피의 가능한 최댓값을 구하시오.

### 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 다음과 같이 구성되어 있다.

테스트 케이스의 첫째 줄에 A, B, C, D가 주어진다. 0 < A,B,C <= 10^18 이고, 0 <= D <= A+B+C-3 이다.

### 출력

각 테스트 케이스에 대해 은주가 남길 수 있는 팬케익의 최대 부피를 차례대로 한 줄에 하나씩 출력한다. 이 부피는 부호있는 64비트 정수 범위 안에 들어온다.

## 문제풀이

이 문제의 경우에는 상당히 간한단데, A,B,C중 최댓값을 뽑아서 그 최댓값이 최댓값이 아니게 될때까지 X번 자르는 것을 반복해 X의 합이 D가 되게 하는것이다.

여기서 시간을 줄이는 방법은 저  x를 조금 더 간단하게 만드는 것인데, x는 D이하이며, A,B,C의 최댓값-중간값+1만큼 줄일 수 있다. 이렇게 줄이는 이유는, 중간값만큼만 빼면 중간값과 같은 값이 되는데 이러면 1씩 빼주는게 되는데 그렇게 반복을 하는것 보다는 그렇게 끝날게 아니면 2씩 빼버리는게 연산이 더 빠르기 때문이다. 이걸이용해서 가장작은값까지 2*(중간-최소)로 빼버리는 방법이있다. 즉 A<B<C이면 B=C가 될때까지 빼주는데 이렇게 해도 D가 0이 되지 않는다면 A=B=C가 될때까지 2씩 b-1, c-1로 빼버리는것이다.이렇게 풀때 는  2×x로 풀리며, a=b=c가 될때까지 반복되거나, d가 0이되면 종료가 된다.

라고 생각해서 풀었는데 틀렸다 다른방법을 찾아봐야 겠다.

### 의사코드

> 1. t를 입력받는다.
>
> 2. t번 반복
>
>    > 1. a,b,c,d를 입력받는다.
>    > 2. 

### 파이썬 코드

```python
import sys
t=int(sys.stdin.readline())
for _ in range(t):
    x=sys.stdin.readline()
    a,b,c,d=map(int, sys.stdin.readline().split())
    nums=[a,b,c]
    nums.sort(reverse=True)
    while d!=0:
        if nums[0]>nums[1] :
            if nums[0]-nums[1]<d:
                d-=(nums[0]-nums[1])
                nums[0]=nums[1]
            else:
                nums[0]-=d
                d=0
        elif nums[0]>nums[2]:
            if nums[0]-nums[2] <= d//2:
                d-=(nums[0]-nums[2])*2
                nums[0]=nums[2];nums[1]=nums[2]
                if d==1:
                    d=0
                    nums[2]-=1
            else:
                nums[0]-=d//2
                nums[1]-=d//2
                if d%2==1:
                    nums[1]-=1
        else:
            nums[0]-=d//3
            nums[1]-=d//3
            nums[2]-=d//3
            if d%3==1:
                nums[2]-=1
            elif d%3==2:
                nums[1]-=1
                nums[2]-=1
    print(nums[0]*nums[1]*nums[2])
```

이 방
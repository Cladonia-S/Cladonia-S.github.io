---
title: "[백준]1300번 - K번째수"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 이진탐색]
---

# K번째 수

## 문제

세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A\[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.

### 입력

첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

### 출력

B[k]를 출력한다.

## 문제풀이

문제의 구성을 생각했을때 직접 B를  구하라는것은 아닐것이다. 그리고 이문제는 이진탐색으로 풀라고 추천된문제임을 생각했을때 임의의 수를 구하고, 이 수보다 적은수의 개수를 이용해 k를 찾아가는게 아닐까 한다. 이 문제의 A배열의 구조상, 무조건 숫자는 i의 배수가 된다. 즉 이를 이용해 mid값을 i로 나눠주는것 만으로 우리는 mid값 보다 작은 수 의 개수를 셀 수 있다. 물론, 배열 A가 N×N 배열이므로, mid/i값은 N을 넘어가면 안될것이다. 이것을 고려해 mid 값보다 작은 수를 세어가면 그 값이 k보다 작을때는 start=mid+1가 될것이고, 아니라면 end=mid-1이 될것이다. 왜 지금까지와 다르게 그냥 mid로 안하냐면, 어짜피 mid는 한번 검사한 대상이라 mid가아니라 그근처의 값으로 넣는게 합리적이라 그리 되엇다.

### 의사코드

> 1. 입력을 받는다.
> 2. start=1, end=k로 정의한다.(이 행렬의 정의를 생각해보면 1*k가 존재하므로 많아도 거기까지만 검사하면된다. i=1일때의 k번째가 k일텐데, i가 1이 아니라고 해도 k보다 작은값이 b의 k번째가되지 그보다 클수는 없다.)
> 3. start <=end 인 동안 반복
>    1. mid=(start+end)//2
>    2. min(mid/i,n)을 i=1~n까지 반복연산한다.
>    3. 그 결과값아 k보다 작으면 start=mid+1 아니면 end=mid-1
> 4. end+1을 출력한다.

### 파이썬 코드

```python
import sys
n=int(sys.stdin.readline())
k=int(sys.stdin.readline())
start=1;end=k
while start <=end :
    mid=(start+end)//2
    c=0
    for i in range(1,n+1):
        if mid//i <0 : break
        c+=min(mid//i,n)
    if c<k : start=mid+1
    else : end=mid-1
print(end+1)
```


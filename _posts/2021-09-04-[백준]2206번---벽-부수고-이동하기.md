---
title: "[백준]2206번 - 벽 부수고 이동하기"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, DFS와 BFS]
---

# 벽 부수고 이동하기

## 문제

N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.

만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.

### 입력

첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.

### 출력

첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.

## 문제풀이

해당 문제는 기본적으로 미로풀기이기때문에 bfs로 푼다.

해당 문제에서 고려해야할 사항은 다음과같다.

- 해당좌표가 맵을 벗어나지 않는지
- 해당좌표가 벽이면 벽을 뚫을 기회가 있는지
- 해당좌표가 벽이 아니면, 방문하지 않을곳이 맞는지

벽을 뚫을수있으면, 기존 맵이 복잡해 지므로, visited함수에 그 값을 넣겠습니다. 들리지 않았다면 0, 들렸다면 0이아닌수가 기록되겠지요.

그리고 벽을 한번도 부수지 않은곳과 벽을 부순곳은 구분되어야 합니다.

정확히는 부순 직후의 세계가 생긴다고 봐야할까요? 벽을 부순 세계는 벽을 부수지 않은 세계로는 돌아갈 수 없습니다. 거기에 벽을 두번 부술수도 없지요. 즉 따로 벽을 부술수 있는지를 queue에 함께 넣어서 구분을 해야한다는 이야기 입니다. 거기에 벽을 넘는 순간은 모두 다르기 때문에 한번 visited한곳이라도 들를 수 있습니다. 단, 그렇게 들리는 경우가 더 최단거리여야겠지요.



### 의사코드

> 1. 입력을 받는다.
> 2. bfs함수선언
>    1. queue를 선언하고, (1,0,0)를 집어넣는다.
>    2. visited\[2]\[n][m]을 선언한다.
>    3. 현재위치에서 상하좌우를 확인합니다.
>       1. 보게된 곳이 목표지점이라면 visited값+1을 출력합니다.
>       2. 만약 벽이라면 벽을 뚫을 횟수가 남아있는지 확인합니다
>          1. 횟수가 남았다면 벽을 뚫습니다.
>             1. 큐에 (0,해당좌표)를 넣습니다.
>             2. visited[0]\[ny][nx]=visited[1]\[y][x]+1
>          2. 횟수가 남지 않았다면 넘어갑니다
>       3. 벽이 아니라면
>          1. 0번세계의 경우 길이고, visited의 값이 0이면 
>             1. 큐에 (1,해당좌표)를 넣고 visitied를 넣어줍니다
>          2. 1번세계의 경우, visited의 값이 0이면 위와 같습니다.
>          3.  visited가 0이 아닐경우 넣을수 있는 visited[1]\[y][x]의 값이 기존값보다 작다면 넣을수 있기는한데 애초에 뎁스로 체크되기때문에 후순위 뎁스는 더 오랜 시간이 걸렸다는 이야기라 의미가 없습니다.
> 3. 시작위치와 끝위치가 같으면 1을 출력하고, 아니면 함수의 결과를 출력한다.

### 파이썬 코드

```python
import sys
from collections import deque
n,m=map(int,sys.stdin.readline().split())
maze=[list(map(int,sys.stdin.readline().rstrip())) for _ in range(n)]
direc=[[-1,0],[0,-1],[1,0],[0,1]]

def bfs():
    queue=deque()
    queue.append([1,0,0])
    visited=[[[0]*m for _ in range(n)] for i in range(2)]
    visited[1][0][0]=1
    while queue: 
        cd, y,x= queue.popleft()
        for i in range(4):
            dy=y+direc[i][0]
            dx=x+direc[i][1]
            if 0<=dx<m and 0<=dy<n:
                if dx==m-1 and dy==n-1:
                    return visited[cd][y][x]+1
                if maze[dy][dx]==1 and cd==1:
                    queue.append([0,dy,dx])
                    visited[0][dy][dx]=visited[1][y][x]+1
                elif maze[dy][dx]==0 and visited[cd][dy][dx]==0 :
                    queue.append([cd,dy,dx])
                    visited[cd][dy][dx]=visited[cd][y][x]+1
    return -1

if n==1 and m==1: print(1)
else: print(bfs())
```


---
title: "[백준]12015번 - 가장 긴 증가하는 부분 수열 2"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 이진탐색]
---

# 가장 긴 증가하는 부분 수열 2

## 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

## 문제풀이

이 문제는 동적계획법 부분에서 보았던 가장 증가하는 부분수열에 관한 문제이다. 세부적으로 다른점은 수열의 크기가 매우 커졌다는것과 추천 방법이 이진탐색이라는 것이다.

이 방법은 어떻게 보면 스택으로 넣는것과 유사한데, 새로 부분수열용 리스트를 선언하고 보고있는 숫자가 리스트의 숫자이하이면 그위치를 해당 숫자로 교체하는것이다. 그리고 리스트의 가장 끝 숫자보다 크다면 그 숫자를 추가하는것이다. 해당 방법은 정확히 LIS를 이루는 요소들을 가르키는것은 아니다. 하지만 길이만 본다면, LIS의 길이가 최대가 될때를 가르킬것입니다. 왜 그러냐 하면 최종길이는 같으나 중간에 수열상으로는 뒤에 있던 원소가 먼저들어온 원소보다 앞으로 들어갈 수 있기 때문입니다. 그림을 이용해 설명하자면 다음과 같습니다.

![LIS2.gif](https://github.com/Cladonia-S/Cladonia-S.github.io/blob/master/images/LIS2.gif?raw=true)

이번에는 직접 이진 탐색 알고리즘을 따로안만들고 bisect모듈을 사용할것 입니다.

이  알고리즘을 이용한 의사코드는 다음과 같습니다.

### 의사코드

> 1. 입력을 받는다.
> 2. 입력받은 수열은 nums, 만들수열은 lis라고 할것이다.
> 3. nums의 숫자를  모두 둘러볼때까지 반복. for i in nums
>    1.  t=bisect.bisect_left(lis,i)# lower_bound 함수와 같다고 보면됨
>    2. if t ==len(lis): lis.append(i)
>    3. else: lis[t]=i
> 4. len(lis)를 출력한다.
---
title: "[백준]1463번-1로 만들기"
categories: 코딩테스트
tags: [알고리즘, 코딩테스트, 동적계획법, python]
---

# 1로 만들기

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

### 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.



## 문제풀이

이 문제의 답은 힌트를 잘 보면 풀기 쉬워진다.  간단히 말하자면 빼기로 일부러 2나 3의배수로 만든다음 나누는게 더 빠르다는 이야기이다. 물론 중간에 2와3의 곱셈이 들어가기도 하기 때문에 지금까지처럼 기록해가며 풀어야한다.  x가 2의 배수일때 x가 1이되는데 필요한 횟수는 x/2가 필요한 횟수에 +1한것일것이다. 3의 배수역시 그 수를 3의로 나눈것의 +1만큼의 횟수가 필요할터이다. 이것을 이용해 의사코드를 만들면 다음과 같이 된다.

### 의사코드

> 1. 입력받는다
>
> 2. 1부터 n까지 수를 올려가며, 연산에 필요한 횟수를 기록한다.
>
>    > 1. i-1번째의 수에 +1 한것을 i번째의 수에 등록한다.
>    > 2. 숫자 i가 3으로 나눠진다면 i//3번쨰 수의 횟수에 +1 한것과 현재 횟수를 비교해 더 작은것을 넣는다
>    > 3. 숫자 i가 2으로 나눠진다면 i//2번쨰 수의 횟수에 +1 한것과 현재 횟수를 비교해 더 작은것을 넣는다
>
> 3. n에 도달했을때의 횟수를 출력한다.



### 파이썬 코드

```python
import sys
n=int(sys.stdin.readline())
c=0
counts=[0,0,1,1,2]
for i in range(5,n+1):
    counts.append(counts[-1]+1)
    if i%3==0:
        counts[i]=min(counts[-1],counts[i//3]+1)
    if i%2==0:
        counts[i]=min(counts[-1],counts[i//2]+1)
print(counts[n])
```


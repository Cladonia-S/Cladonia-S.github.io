---
title: "[백준]11054번 - 가장 긴 바이토닉 부분 수열"
categories: 코딩테스트
tags: [알고리즘, 코딩테스트, 동적계획법, python]
---

# 가장 긴 바이토닉 부분 수열

## 문제

수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, **30**, 25, 20}과 {10, 20, 30, **40**}, {**50**, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

### 출력

첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.



## 문제 풀이

이 문제는 이전에 풀었던 가장 긴 증가하는 부분 수열과 비슷한 문제이다. 바이토닉 수열을 세는 방법은 특정 위치에서의 가장 긴 증가하는 부분수열과 감소하는 부분 수열을 더하면 될 것이다. 물론 ㅅ 모양이나 \ /여야 바이토닉 수열이지 V나 체크표시 같이되는것은 바이토닉이 아니므로, 이에 유념하도록 하자. 즉 특정위치 i에서 자기보다 앞에있는 것은 본인보다 감소하는 수열이여야하고, 본인보다 뒤에있는것은 증가하는 수열이여야 한다.

### 의사 코드

> 1. 입력을 받는다.
>
> 2.  현재위치에서 가지는 증가하는 부분수열의 길이와 감소하는 부분수열의 길이를 구하는 함수를 만든다.
>
>    > 1. 가장 긴 증가하는 함수는 앞에서부터 증가하는 수를 센다.
>    > 2. 가장 긴 감소하는 함수는 뒤에서부터 증가하는 수를 센다.
>
> 3. 구해진 증가부분수열과 감소부분수열을 합하고 1을 빼 현위치에서의 바이토닉 수열을 구한다.



### 파이썬 코드

```python
import sys
n=int(sys.stdin.readline())
nums=list(map(int,sys.stdin.readline().split()))
lbs=[0]*n
lis=[1]*n
lds=[1]*n
for i in range(1,n):
    mnum=0
    for j in reversed(range(i)):
        if nums[i]>nums[j] and lis[j]>mnum:
            mnum=lis[j]
    lis[i]=mnum+1
for i in reversed(range(n-1)):
    mnum=0
    for j in range(i+1,n):
        if nums[i]>nums[j] and lds[j]>mnum:
            mnum=lds[j]
    lds[i]=mnum+1
for i in range(n):
    lbs[i]=lis[i]+lds[i]-1

print(max(lbs))
```


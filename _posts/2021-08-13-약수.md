---
title : "[백준]1037번 - 약수"
categories: 코딩테스트
tags: [코딩테스트, 백준, 알고리즘, 정수론 및 조합론, python]
---

# 약수

## 문제

양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤수 N의 진짜 약수가 모드 주어질떄 N을 구하는 푸로그램을 작성 하시오.

### 입력

첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.

### 출력

첫째 줄에 N을 출력한다. N은 항상 32비트 부호있는 정수로 표현할 수 있다.



## 문제풀이

이 문제는 생각보다 매우 간단하게 풀수 있다.  어떤수던 약수는 짝을 이룬다. 두 수가 곱해져 N을 이루는것이다. 그렇지 않은수는 약수가 존재하지않는 소수 뿐이다. 따라서 우리는 이것의 짝을 맞춰서 곱해주기만하면된다. 그리고 이 문제에서는 모든 진짜 약수를 준다고 했다. 그렇다면 받은 약수들을 정렬한후 가장 큰 값과 가장 작은 값을 곱한것이 N이 된다.

### 의사코드

> 1. 입력받는다.
> 2. 약수들을 정렬한다
> 3. 제일작은 수와 제일큰수를 곱한후 출력한다.



### 파이썬 코드

```python
import sys
n=int(sys.stdin.readline())
factors=list(map(int, sys.stdin.readline().split()))
factors.sort()
print(factors[0]*factors[-1])
```


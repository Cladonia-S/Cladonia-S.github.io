---
title: "[백준]2110번 - 공유기 설치"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 이진탐색]
---

# 공유기 설치

## 문제

도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.

도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.

C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

### 입력

첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.

### 출력

첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.

## 문제풀이

 일단 확정은 양끝에는 하나씩 공유기가 있을것이란 것이다. 왜냐하면 공유기는 최소 두개이고, 그것을 가장 멀리 설치하는 방법은 양끝에 설치하는것 이기 때문이다. 그러니 우선은 집들의 좌표를 오름 차순으로 정렬해야한다. 집들 사이의 거리의 최솟값은 1일것이고, 최댓값은 첫번째집과 마지막집 사이의거리일것이다. 우리가 구해야 하는것은 집들 사이의 거리이기 때문에  확인조건은 공유기의 개수이고, 결과조건이 길이가 될것이다. 그런즉, 길이(mid)를 간격으로 공유기가 설치되고, 그것을 이용해 집에 설치된 공유기 개수를 재면 될것이다. 다만 그것이 단순한 나눗셈이여서는 안된다. 집간의 길이가 상이하기 때문이다.  전에 설치한 집과의 거리가 mid이상이면 새로 설치 했다고 보고, 이때의 집을 기준으로 바꾼다. 이렇게 설치된 개수를 세어 보면 공유기 개수가 나올것이고, 공유기 개수가 모자라다면 추가로 공유기를 설치해야한다(x<c). 따라서 간격을 줄이면 된다(start=mid) 반대의 경우에는 간격을 늘리면 되고 말이다.

따라서 다음과 같은 의사코드가 생성된다.

### 의사코드

> 1. 입력받는다.
> 2. 오름차순 정렬한다.
> 3. start=1;  end=coord[-1]-coord[0]
> 4. 결과가 나올때까지 반복
>    1. mid=(start+end)//2
>    2. if mid==start: break
>    3. prev=coord[0]
>    4. for i in range(n):
>       1. if coord[i]-prev >= mid : 
>          1. x+=1
>          2. prev=coord[i]
>    5. if x<c: start=mid
>    6. else: end=mid

### Python Code

```python
import sys
n,c=map(int, sys.stdin.readline().split())
coord=[int(sys.stdin.readline()) for _ in range(n)]
coord.sort()
start=0;end=coord[-1]-coord[0]
mid=(start+end)//2
if c==2:
    print(end)
else:
    while start!=mid:
        prev=coord[0]
        x=1
        for i in coord[1:]:
            if i-prev >= mid:
                prev=i
                x+=1
        if x< c: end=mid
        else : start=mid
        mid=(start+end)//2
    print(start)
```


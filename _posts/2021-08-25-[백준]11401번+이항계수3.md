---
title: "[백준]11401번 - 이항계수3"
categoties: 코딩테스트
tags: [백준, 코딩테스트,알고리즘, python, 분할정복]
---

# 이항 계수 3

## 문제

자연수 N과 정수 K가 주어졌을 때 이항 계수 (NK)를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 4,000,000, 0 ≤ K ≤ N)

### 출력

 (NK)를 1,000,000,007로 나눈 나머지를 출력한다.

## 문제풀이

이전까지 우리는 이항계수가 가지는 성질이용해 O(N²)의 시간을 가지는 전처리를 통해 한번에 연산하고 요청들을 O(1)로 처리 했습니다, 하지만 이 번 이항계수 3번은 입력이 매우 크기때문에 그 방법을 적용할 수 없습니다.

그래서 다른방법을 이용해야하는데 그 방법이 모듈러를 이용한 분할정복입니다. 출력에 보면 1000000007로 나눠주라고 되어있는데 이 수 는 소수 입니다.  이럴때만 이용할수 있는 방법이 있는데 **페르마의 소정리**를 이용하는것입니다. 모듈러 부분부터 갑자기 너무 수학적이 되서 어려워 하실수있지만 어쩔수 없습니다..

페르마의 소정리란 
$$
a^{p-1}≡1(mod\;p)
$$
위와 같은 수식인데, 이를 이용해 모듈러 값이 1이되는 역원을 구한다고 보면됩다. 모듈러의 성질에 따라 위  식은 다음과 같이 변경될 수 있는데
$$
a×a^{p-2}≡1(mod\;p)
$$
이에 따라 a의 역원은 a^{p-2}가 됩니다. 그리고 이식을 한번 더 변형하면 다음과 같은 식이되는데, 
$$
a^{p-2}≡\frac {1}{a}(mod\; p)
$$
이를 이용하면 조합식을 다음과 같이 바꿀 수 있습니다.
$$
_nC_k(mod\;p)\;=\frac{n!}{k!(n-k)!}(mod\;p)≡n!(k!(n-k)!)^{p-2}\;(mod\;p)
$$
여기서 이 식이 분할정복인 이유가 나옵니다. 저 제곱값을 분할정복으로 푸는것입니다.

여기서 한가지 더 사용할수 있는 방법이있는데 
$$
n×\frac{1}{n!} = \frac{1}{(n-1)!}
$$
를 이용하는 것 입니다. 이를 이용해 처음 n!^{p-2}를 구하고 그아래로는 n을 곱해주는 식으로 풀면 쉽게 값을 구할 수 있는 것입니다. 확인결과 이거까지 메모제이션 해버리면 메모리 초과가 나올수도 있습니다.

### 의사코드

> 1. 입력을 받는다.
> 2. 분할정복 (모듈러) 제곱함수를 만든다.
> 3. 메모제이션기법을 통해 팩토리얼을 구한다.
> 4. 위 수식을 이용해 필요한 값을 푼다.

### 파이썬 코드

```python
import sys
def divPowM(x,y):
    ret=1
    while y>0:
        if y%2==1:
            ret*=x
            ret=ret%1000000007
        x*=x
        x=x%1000000007
        y=y//2
    return ret
n,k=map(int,sys.stdin.readline().split())
facto=[1]*(n+1)
for i in range(2,n+1):
    facto[i]=(facto[i-1]*i)%1000000007
x=(facto[k]*facto[n-k])%1000000007
z=divPowM(x,1000000005)
ret=(facto[n]*z)%1000000007
print(ret)
```


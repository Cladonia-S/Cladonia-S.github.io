---
title: "[백준]11404번 - 플로이드"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 최단경로, 플로이드 와샬]
---

# 플로이드

## 문제

n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

### 출력

n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.

## 문제풀이

문제에서 알 수 있듯이 이 문제는 모든 도시에 대하여 최단 거리를 구해야 하는 문제이다. 다익스트라로 푸려면 도시의 수 만큼 다익스트라를 해줘야 하기때문에 우리는 플로이드 와셜 알고리즘을 사용 할 예정이다. 익숙하겠지만, 이는 dp를 사용하는것과같다. 2차원 dp와 같이 dp\[i][j]는 i부터 j까지 가는 최단거리를 나타낸다.

### 플로이드 와샬 알고리즘

플로이드 와샬 알고리즘에서도 이 최단거리들을 반복적으로 갱신하여 구하는데, 이때 반복되는 기준이 바로 노드이다. 노드i를 거쳐서 구했는지를 기준으로 

- A애서 B까지 가는 비용 VS A에서 i로가는 비용 +i에서 B로 가는 비용을 구하면 된다.

 만약 후자가 더 비용이 적다면 후자로 갱신된다.

물론 시작노드, 도착노드, 거쳐가는 노드 전부다 미지수이므로 셋다 반복문이 필요하기 때문에 시간은 많이 걸린다.

### 의사코드

> 1. 위 두줄을 입력받는다.
> 2. (n)*(n)사이즈 배열을 만든다. 내부 초기값은 100001
> 3. 버스를 읽어온다
>    1. a,b,c로 하면 dp\[a-1][b-1]=min(dp\[a-1][b-],c)
> 4. 폴로이드 와샬 알고리즘을 만든다.
>    1. n, 2차원 배열을 받아 갱신한다.
> 5. 결과를 출력한다.

### Python

```python
import sys
import math
n=int(sys.stdin.readline())
m=int(sys.stdin.readline())
INF=math.inf
dp=[[INF]*n for _ in range(n)]
#init
for i in range(n):
    dp[i][i]=0
for _ in range(m):
    a,b,c=map(int,sys.stdin.readline().split())
    dp[a-1][b-1]=min(dp[a-1][b-1],c)
def floydWarshall(n,dp):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dp[i][k]+dp[k][j]< dp[i][j]:
                    dp[i][j]=dp[i][k]+dp[k][j]
floydWarshall(n,dp)
for  i in dp:
    for j in i:
        if j==INF:
            print('0',end=' ')
        else : print(j, end=' ')
    print()
```


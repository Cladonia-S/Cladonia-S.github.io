---
title: "[백준]6549번 - 히스토그램에서 가장 큰 직사각형"
categoties: 코딩테스트
tags: [백준, 코딩테스트,알고리즘, python, 분할정복]
---

# 히스토그램에서 가장 큰 직사각형

## 문제

히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.

![img](https://www.acmicpc.net/upload/images/histogram.png)

히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.

### 입력

입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.

## 출력

각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.

## 문제풀이

이 문제도 꽤나 유명한 문제인데 푸는 방법이 다양해서 더 그런것같다.

이 문제를 푸는 방법은 어떻게 보면 간단한데 스택을 이용해 풀 수 있다. (스택으로 푼 이유는 다른 방법으로 했는데 시간에 문제가 생겼기 때문이다. 분할정복 카테고리에있는데 시간이 문제가 생긴거보면 아마도 내가 짠 풀이법이 잘못된 부분이있었겠지.) 

이론을 설명하는것 보다는 그림으로 보는게 이해가 편할것 같아서 gif파일로 풀이를 준비했다.



![HistogramBigRactangle.gif](https://github.com/Cladonia-S/Cladonia-S.github.io/blob/master/images/HistogramBigRactangle.gif?raw=true)

위와 같은 원리로 푸는것인데, 시간복잡도는 O(n)정도로 나온다.

위 gif파일을 의사코드로 나타내면 다음과 같다.

### 의사코드

> 1. 입력받는다.
> 2. stack=[-1] 선언
> 3. 모든 인덱스를 볼때까지 반복.
>    1. 스택에 값이 있고, 스택의 top을 인덱스로 가지는 값이 현재 값보다 크다면
>       1. 인덱스를 pop하고 그 인덱스의 값을 **값*(현재 인덱스- 왼쪽끝인덱스(stack.top()-1))** 로 바꿔준다.
>       2. 아니라면, 현재 인덱스를 스택에 넣어주고 다음 값을 본다.
> 4. 스택길이 -1 동안 반복(뒤에서부터):
>    1. 현재 값보다 스택의 값이 크면 
>       1. 인덱스를 pop하고 그 인덱스의 값을 **값*(오른쪽끝 인덱스(n)- 왼쪽끝 인덱스(stack[-1]))** 로 바꿔준다.
>       2. 아니라면 , 다음 스택 값을 본다.
> 5. 스택에 남은 값이 가장 작은 값일것이므로, 이 값에 **히스토그램의 전체길이(n**)을 곱해 넣어준다.
> 6. 결과 값중 가장 큰 값을 출력한다.

### 파이썬 코드

```python
import sys
while True:
    n=list(map(int, sys.stdin.readline().split()))
    if n[0]==0:
        break
    else:
        h=n[1:]
        n=n[0]
        stack=[-1]
        i=0
        while i<n:
            if len(stack)>1 and h[stack[-1]]>h[i]:
                h[stack.pop()]*=(i-stack[-1]-1)
            else :
                stack.append(i)
                i+=1
        i=len(stack)-2
        while i>0 :
            if stack and h[stack[-1]]>h[stack[i]]:
                h[stack.pop()]*=(n-stack[-1]-1)
            else: i-=1
        h[stack[-1]]*=n
        print(max(h))
```


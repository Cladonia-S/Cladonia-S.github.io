---
title: "[백준]1956번 - 운동"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 최단경로]
---

# 운동

## 문제

V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.

당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.

도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.

### 입력

첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.

### 출력

첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.

## 문제풀이

말그대로 그래프에서 사이클을 구하는 문제이다. 가장 짧은 사이클의 길이를 구하는것이 중요한데, 이에 필요한 효율적인 알고리즘은 따로있는것으로 알고있으나, 정확히는 모르기때문에~ 넘어가도록하겠다.

일단 내가 할수있는 가장 간단한 방법은 플로이드 와샬 알고리즘을 통해서 모든 최단거리를 구한후, 출발지점과 도착지점이 같은 것들에 한하여 최단 거리 검사를 하는것이다. 이때 결과로 INF가 아닌것이 나왔다면 그것은 즉, 사이클이 있다는 의미가 되므로 이 것들의 값이 가장작은 값을 구한다면 그것이 답이될것이다. 물론 전부 INF라면 사이클이 없다는 의미가 되므로 -1을 출력해 주면 된다. 



### 파이썬 코드

```python
import sys
import math
INF=math.inf
#Floyd Warshall
def floydWarshall(n,dp):
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dp[i][k]+dp[k][j]< dp[i][j]:
                    dp[i][j]=dp[i][k]+dp[k][j]
#init
V, E =map(int, sys.stdin.readline().split())
dp=[[INF]*V for i in range(V)]
#dp_ init
for i in range(E):
    a,b,c=map(int,sys.stdin.readline().split())
    dp[a-1][b-1]=c
#init end
floydWarshall(V,dp)
minii=INF
for i in range(V):
    minii=min(minii,dp[i][i])
if minii==INF:
    print(-1)
else:
    print(minii)
```

가장효율적인것이 아닌 일단 할수있는 코드로 처리해서인지 그렇게 까지 효율적인 코드는 아니다Pypy3로 해야 통과되는 코드이니 주의할것.
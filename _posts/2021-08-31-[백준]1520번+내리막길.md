---
title: "[백준]1520번 - 내리막길"
categories: 코딩테스트
tags: [백준, 코딩테스트, 알고리즘, 파이썬, 다이나믹 프로그래밍 2, 동적계획법2]
---

# 내리막길

## 문제

여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.

![img](https://upload.acmicpc.net/0e11f3db-35d2-4b01-9aa0-9a39252f05be/-/preview/)

현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.

![img](https://upload.acmicpc.net/917d0418-35db-4081-9f62-69a2cc78721e/-/preview/) ![img](https://upload.acmicpc.net/1ed5b78d-a4a1-49c0-8c23-12a12e2937e1/-/preview/) ![img](https://upload.acmicpc.net/e57e7ef0-cc56-4340-ba5f-b22af1789f63/-/preview/)

지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.

### 출력

첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

## 문제풀이

이 문제는 지금까지와는 조금 다르게 이동 지점이 2차원 평면입니다. dp에서 일반적으로 시작위치와 도착위치가 현재지점과 도착지점을 나타낸다는것을 생각하면 답을 적기 애매할 수 있습니다. 따라서 2차원으로 표시하되, 항상 시작지점은 (0,0)으로보고 `dp[i][j]`는 (i,j)에서 (n,m)까지 갈때 갈 수 있는 거리의 수 라고 생각해야 합니다.

하지만 이것만으로는 모자랄거 같습니다. 그러면 여기서 dp만이 아닌 다른 방법, 즉 백트래킹을 사용해 줍니다. 이미 다녀간곳이면 dp에 저장된 길이만 더하면 될 뿐입니다. 지나온적 없는 길이라면 이동을 해봐야 지요. 지나온 곳인지 판정하는것은 dp를 -1로 선언하고, 그곳에 도착하면 0으로 선언후, 구해진 값을 더하는 것으로 봐야 합니다.

그렇다면  이제 필요한것들은 다 나왔으니 의사코드로 정리하면 됩니다. 아, 하나를 안했군요. 이 재귀는 최대 250000까지 재귀호출을 해야하는데, 파이썬의 기본 재귀호출 설정은 1000번이기 때문에 `sys.setrecursionlimit(250000)`를 해줘야 합니다.

### 의사코드

> 1. 입력 받는다.
> 2. dp=[[-1]*[n] for _ in range(m)]
> 3. direc=[[1,0],[0,1],[-1,0],[0,-1]]
> 4. dfs 함수 선언(x,y):
>    1. global dp
>    2. 만약 x==n-1이고 y==m-1이면 1리턴
>    3. 1이 아니고 dp\[y][x]가 -1이라면
>       1. dp\[y][x]=0
>       2. k=0~3까지 반복
>          1. nx=x+direc\[k][0];ny=y+direc\[k][1]
>          2. nx가 0이상이고, n미만이고, ny가 0이상이고, n미만이며, h\[y][x]>h\[ny][nx]이면 dp\[y][x]+=dfs(nx,ny)
>    4. dp\[y][x] 리턴
> 5. print(dfs(0,0))

### Python code

```python
import sys
sys.setrecursionlimit(250000)
m,n=map(int, sys.stdin.readline().split())
h=[list(map(int,sys.stdin.readline().split())) for _ in range(m)]
dp=[[-1]*n for _ in range(m)]
direc=[[1,0],[0,1],[-1,0],[0,-1]]
def dfs(y,x):
    global dp
    if x==n-1 and y==m-1: return 1
    elif dp[y][x]== -1:
        dp[y][x]=0
        for k in range(4):
            nx=x+direc[k][0];ny=y+direc[k][1]
            if nx>-1 and nx<n and ny >-1 and ny <m and h[y][x]>h[ny][nx]:
                dp[y][x]+=dfs(ny,nx)
    return dp[y][x]
print(dfs(0,0))
```


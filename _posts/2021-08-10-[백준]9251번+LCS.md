---
title : "[백준]9251번 - LCS"
categories: 코딩테스트
tags: [코딩테스트, 파이썬, 백준, 동적계획법]
---

# LCS

## 문제

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

### 입력

첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

### 출력

첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.



## 문제 풀이

위의 문제를 기준으로 예시를 들어 보겠다.

|      |  A   |  C   |  A   |  Y   |  P   |  K   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  C   |  0   |  1   |  0   |  0   |  0   |  0   |
|  A   |  1   |  0   |  1   |  0   |  0   |  0   |
|  P   |  0   |  0   |  0   |  0   |  1   |  0   |
|  C   |  0   |  1   |  0   |  0   |  0   |  0   |
|  A   |  1   |  0   |  1   |  0   |  0   |  0   |
|  K   |  0   |  0   |  0   |  0   |  0   |  1   |

여기서 같은 문자에 1을 아닌문자에 0을 집어넣으면 위와 같은 표가 된다. 그리고 i와 j가 보는 기준을 생각 해볼때, i열의 j행까지 본다는것은 각 문자열을 i개, j개로 잘랐을 때의 겹치는 문자의 개수로 만든다고 생각해보면 다음과 같은 표가 나온다.

|      |  A   |  C   |  A   |  Y   |  P   |  K   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  C   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  1   |      |      |      |      |      |
|  P   |  1   |      |      |      |      |      |
|  C   |  1   |      |      |      |      |      |
|  A   |  1   |      |      |      |      |      |
|  K   |  1   |      |      |      |      |      |

다음처럼 표가 채워진다.  이는 ACAYPK와 C는 AC이후의 ACAYPK의 모든 문자열은 C를 포함하므로 LCS가 1이라는 이야기이다. 마찬가지의 이유에서 CAPCAK와 A역시같다. 즉 현재 위치에서 봐야할것은 자신을 기준으로 위쪽의 값과 왼쪽숫자의 값이 된다. 왼쪽값과 윗쪽값중 큰쪽을 고른 후, 자기 자신이 무언가 다른수와 만난다면 +1을 아니라면 0을 더하는것이다. 표를 좀더 채우면

|      |  A   |  C   |  A   |  Y   |  P   |  K   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  C   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  1   |  1   |  2   |  2   |  2   |  2   |
|  P   |  1   |  1   |  @   |      |      |      |
|  C   |  1   |  2   |      |      |      |      |
|  A   |  1   |  2   |      |      |      |      |
|  K   |  1   |  2   |      |      |      |      |

이렇게 된다 그러면 저기 @표시에 들어가는 값은 ACA와 CAP가 가지는 LCS의 길이가 된다. 이 길이는 ACA와 CA, AC 와 CAP에서 겹치는 수의 개수중 더 큰수의 값이 된다. 답은 CA인 2가 되고 말이다. 그리고 이렇게 왼쪽숫자와 윗쪽숫자를 비교해 끝까지 채우면

|      |  A   |  C   |  A   |  Y   |  P   |  K   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  C   |  0   |  1   |  1   |  1   |  1   |  1   |
|  A   |  1   |  1   |  2   |  2   |  2   |  2   |
|  P   |  1   |  1   |  2   |  2   |  3   |  3   |
|  C   |  1   |  2   |  2   |  2   |  3   |  3   |
|  A   |  1   |  2   |  3   |  3   |  3   |  3   |
|  K   |  1   |  2   |  3   |  3   |  3   |  4   |

결과 값은 다음과 같이 4가 된다. 이 것을 의사 코드로 바꿔보자.



### 의사코드

> 1.  입력을 받는다.
> 2. 문자의 길이를 이용해 0으로 선언한 행렬을 만든다.
> 3. 행렬 값을 넣는다 (반복)
>    1. 현위치의 문자가 같으면, 이전에 중복문자가 있으면 안되므로, `[i-1][j-1]+1`을 값에 넣는다.
>    2. 문자가 다르면, `[i-1][j]`와 `[i][j-1]`을 비교한다.
>
> 4. `[-1][-1]`값을 출력한다.



### 파이썬 코드

```python
import sys
s1=sys.stdin.readline().rstrip()
s2=sys.stdin.readline().rstrip()
l1=len(s1); l2=len(s2)
arr=[[0]*(l1+1) for _ in range(l2+1)]
for i in range(l2):
    for j in range(l1):
        if s1[j]==s2[i]:
            arr[i+1][j+1]=arr[i][j]+1
        else :
            arr[i+1][j+1]=max(arr[i+1][j], arr[i][j+1])
print(arr[-1][-1])
```

